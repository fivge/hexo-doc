---
title: Linux2.2.4 管道命令
tags:
- shell
- Linux
date: 2016-10-26 14:26:43
---

# 一、命令执行顺序的控制

1.简单的顺序执行你可以使用 ; 来完成    

2.有选择的执行命令 && ||    
它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果    
||在这里就是与&&相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令    

# 二、管道

管道是什么,管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin).    
管道又分为匿名管道和具名管道（这里将不会讨论在源程序中使用系统调用创建并使用管道的情况，它与命令行的管道在内核中实际都是采用相同的机制）。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示，|在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的"过滤程序"来帮助你熟练管道的使用。    

<!-- more -->

## 1. |less

## 2.cut命令，打印每一行的某一字段

打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录

```shell
cut /etc/passwd -d ':' -f 1,6
```
打印/etc/passwd文件中每一行的前N个字符

前五个（包含第五个）

```shell
cut /etc/passwd -c -5
```
前五个之后的（包含第五个）

```shell
cut /etc/passwd -c 5-
```
第五个

```shell
cut /etc/passwd -c 5
```
2到5之间的（包含第五个）

```shell
cut /etc/passwd -c 2-5
```
## 3.grep命令，在文本中或stdin中查找匹配字符串


grep命令的一般形式为：

grep [命令选项]... 用于匹配的表达式 [文件]...

还是先体验一下，我们搜索/home/shiyanlou目录下所有包含"shiyanlou"的所有文本文件，并显示出现在文本中的行号

```shell
grep -rnI "shiyanlou" ~
```
-r 参数表示递归搜索子目录中的文件,-n表示打印匹配项行号，-I表示忽略二进制文件。这个操作实际没有多大意义，但目的在于告诉你grep命令的强大与实用，你看确是输出了匹配项，及匹配内容在哪个文件中的哪一行，反正你在windows是不能如此方便的干这件事的。

当然你可以在匹配字段中使用正则表达式,下面简单的演示

查看环境变量中以"yanlou"结尾的字符串
```shell
export | grep ".*yanlou$"
```
其中$就表示一行的末尾

## 4.wc命令，简单小巧的计数工具

注意哈，此wc非彼"WC(Water Closet)",wc命令用于统计并输出一个文件中行、单词和字节的数目

比如输出/etc/passwd文件的统计信息

```shell
wc /etc/passwd
```
分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数

行数
```shell
wc -l /etc/passwd
```
单词数
```shell
wc -w /etc/passwd
```
字节数
```shell
wc -c /etc/passwd
```
字符数
```shell
wc -m /etc/passwd
```
最长行字节数
```shell
wc -L /etc/passwd
```
注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉子是大于2个字节的，具体数目是由字符编码决定的
再来结合管道来操作一下。下面统计/etc下面所有目录数

```shell
ls -dl /etc/*/ | wc -l
```
## 5.sort排序命令

这个命令前面我们也是用过多次了，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等

默认为字典排序

```shell
cat /etc/passswd | sort
```
反转排序

```shell
cat /etc/passwd | sort -r
```
按特定字段排序

```shell
cat /etc/passwd | sort -t':' -k 3
```
上面的-t参数用于指定字段的分隔符，这里是以":"作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是一字典序排序的，如果要按照数字排序就要加上-n参数

```shell
cat /etc/passwd | sort -t':' -k 3 -n
```
## 6.uniq去重命令

uniq命令可以用于过滤或者输出重复行

过滤重复行
我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了那个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令

```shell
history | cut -c 8- | cut -d ' ' -f 1 | uniq
```
然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它趋势去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们只能先排个序了

```shell
history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq
```
或者

```shell
history | cut -c 8- | cut -d ' ' -f 1 | sort -u
```
然后就对了，你接着可能会惊叹，哇才这么几个命令啊，可怎么感觉自己干了好多好厉害的事情了呢，哈哈，这就是Linux/Unix哲学吸引人的地方了，大繁至简，一个命令只干一件事却能干到最好（虽然不全是这样，但也差不多）。

输出重复行
输出重复过的行（重复的只输出一个）及重复次数
```shell
history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc
```
输出所有重复的行
```shell
history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D
```
文本处理命令还有很多，下一节将继续介绍一些常用的文本处理的命令

***

***

# 文本处理命令

## 1.`tr`(处理单个/多个字符)
### ①`-d`	删除匹配的字符

```shell
 echo 'hello shiyanlou' | tr -d 'olh'
```
### ②`-s`	去除连续并重复的字符

```shell
 echo 'hello' | tr -s 'l'
```
### ③`tr A B`  把字符A转化为字符B

```shell
 cat /etc/passwd | tr '[:lower:]' '[:upper:]'  
```
将输入文本，全部转换为大写或小写输出    
  上面的`[:lower:]` `[:upper:]`你也可以简单的写作`[a-z]``[A-Z]`

## 2.`col`
+ `-x`	将Tab转换为空格
  + `-h`将空格转换为Tab**（默认选项）**

## 3.`join `
将两个文件中包含相同内容的那一行合并在一起

+ `-t`	指定分隔符，默认为空格
  + `-i`忽略大小写的差异
  + `-1`指明第一个文件要用哪个字段来对比，，默认对比第一个字段
  + `-2`指明第二个文件要用哪个字段来对比，，默认对比第一个字段    

操作举例：
1)
```shell
echo '1 hello' > file1
echo '1 world' > file2
join file1 file2
```
2)将/etc/passwd与/etc/shadow两个文件合并，指定以':'作为分隔符

```shell
sudo join -t':' /etc/passwd /etc/shadow
```
3)将/etc/passwd与/etc/group两个文件合并，指定以':'作为分隔符, 分别比对第4和第3个字段

```shell
sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group
```

## 4.`paste`
它是在不对比数据的情况下，简单粗暴的将多个文件合并一起

+ `-d`	指定合并的分隔符，默认为Tab
  + `-s`不合并到一行，每个文件为一行